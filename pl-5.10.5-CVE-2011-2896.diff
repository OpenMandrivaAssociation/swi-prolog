
Loading incomplete GIF files causes an invalid read:
http://www.swi-prolog.org/git/packages/xpce.git/commit/797226335ec47573f80e84d0fbdf1536292868d0

Make sure all pixels are within the allocated colormap:
http://www.swi-prolog.org/git/packages/xpce.git/commit/4bc3a0a32132c04b11ad83f2b5847be83ab7364b

--- packages/xpce/src/img/gifread.c	2011-08-18 22:48:57.000000000 +0200
+++ packages/xpce/src/img/gifread.c.oden	2011-11-04 14:24:21.399511847 +0100
@@ -69,6 +69,7 @@ static int LZWReadByte (IOSTREAM *fd,int
 static int ReadImage(IOSTREAM *fd,
 		     PIXEL *bigMemBuf,
 		     int width, int height,
+		     int ncolors,
 		     int interlace);
 
 
@@ -251,14 +252,14 @@ GIFReadFD(IOSTREAM *fd,
 	return rval;
       }
       /*read image */
-      if ( (rval=ReadImage(fd, bigBuf, w, h,
+      if ( (rval=ReadImage(fd, bigBuf, w, h, bitPixel,
 			   BitSet((UCHAR) buf[8], INTERLACE))) != GIF_OK )
       { setGifError("Error reading GIF file.  LocalColorMap. Giving up");
 	pceFree(bigBuf);
 	return rval;
       }
     } else
-    { if ( (rval=ReadImage(fd, bigBuf, w, h,
+    { if ( (rval=ReadImage(fd, bigBuf, w, h, GifScreen.BitPixel,
 			   BitSet((UCHAR) buf[8], INTERLACE))) != GIF_OK )
       { setGifError("Error reading GIF file.  GIFScreen Colormap.  Giving up");
 	pceFree(bigBuf);
@@ -548,12 +549,15 @@ static int
 ReadImage(IOSTREAM *fd,
 	  PIXEL *bigMemBuf,
 	  int width, int height,
+	  int ncolors,
 	  int interlace)
 {
   UCHAR c;
   int color;
   int xpos = 0, ypos = 0, pass = 0;
+  int lines = 0;
   long curidx;
+  int last;
 
   if ( !ReadOK(fd, &c, 1) || c > MAX_LZW_BITS )
   { return GIF_INVALID;
@@ -565,6 +569,10 @@ ReadImage(IOSTREAM *fd,
   {
     curidx = (long) xpos + (long) ypos *(long) width; /* optimize */
 
+    if ( color >= ncolors )
+    { /*Cprintf("Color %d; ncolors = %d\n", color, ncolors);*/
+      return GIF_INVALID;
+    }
     bigMemBuf[curidx] = color;
 
     ++xpos;
@@ -606,20 +614,23 @@ ReadImage(IOSTREAM *fd,
 	  }
 	}
       } else
-      {
-	++ypos;
+      { ++ypos;
       }
+      ++lines;
     }
     if (ypos >= height)
-      break;
+      goto fini;
   }
+  return GIF_INVALID;			/* short file */
 
 fini:
+  if ( lines != height )
+    return GIF_INVALID;
 
-  if (LZWReadByte(fd, FALSE, c) >= 0)
-  {
+  if ( (last=LZWReadByte(fd, FALSE, c)) >= 0 )
+  { return GIF_OK;			/* end is 0x3B, but we only read the */
+  }					/* first image of animated GIFs */
 
-  }
-  return GIF_OK;
+  return GIF_INVALID;
 }
 
